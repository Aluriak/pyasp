%gringo-3.0.3 testall.txt ../src/query/inflgraph_with_no_change_observations/prediction_core_with_nc.gringo | clasp-2.0.2-mt  --stats  --restart-on-model --opt-heu --save-pro  --opt-hier  --heu=vmtf --opt-all=6,18 --project --brave
input(P,V) :- exp(P), input(V).
exp(P) :- obs_vlabel(P,V,S).
exp("empty") :- 0{obs_vlabel(P,V,S)}0.

% auxiliary definitions
sign(-1;1).
complement(S,-S) :- sign(S).

% get errornodes from the previous computation step
err(V) :- err(V,P).

prederr(V,P) :- err(V,P).
prederr(U,P) :- not input(P,U), not obs_vlabel(U,P), r_edge(U,V), prederr(V,P).

% possible repairs
pos(aedge("unknown_plus",V))   :- vertex(V), exp(P), prederr(V,P), not input(P,V).
pos(aedge("unknown_minus",V))   :- vertex(V), exp(P), prederr(V,P), not input(P,V).

vlabel(P,"unknown_plus",1):- exp(P).
vlabel(P,"unknown_minus",-1):- exp(P).

% choose repair
 { repair(R) } :- pos(R).

% new subset based approach
subset(A,end,1,V) :- edge(A,V).
subset(A,subset(B,S),N+1,V) :- subset(A,end,1,V), subset(B,S,N,V), vertex(A) < vertex(B).

in(A,subset(A,S)) :- subset(A,S,N,V).
in(B,subset(A,S)) :- in(B,S), subset(A,S,N,V).

{keep(subset(A,S),N,V)} :- subset(A,S,N,V).
% Avoid redundant edges such as: A or (A and B)
:- keep(S1,N,V), keep(S2,M,V), S1!=S2, in(A,S2) : in(A,S1).

keep(U,V) :- keep(S,N,V), in(U,S).

% remaining edges

r_edge(U,V) :- repair(aedge(U,V)).
r_edge(U,V) :- keep(U,V).


% here comes the choice rules
1{vlabel(P,V,1), vlabel(P,V,-1), vlabel(P,V,0)}1 :- exp(P), vertex(V), not input(P,V).
% 1{vlabel(P,U,1), vlabel(P,U,-1), vlabel(P,U,0)}1 :- exp(P), edge(U,V), not input(P,V).

elabel(U,V,S) :-        r_edge(U,V), not elabel(U,V,T), complement(S,T).
elabel(U,V,1) :- repair(aedge(U,V)).

% construct consistent total labeling
elabel(U,V,S) :- not repair(eflip(U,V,S)), r_edge(U,V), obs_elabel(U,V,S).
elabel(U,V,T) :-     repair(eflip(U,V,S)), r_edge(U,V), obs_elabel(U,V,S), complement(S,T).

vlabel(P,V,S) :- exp(P), vertex(V), obs_vlabel(P,V,S).


%observed nodes
obs_vlabel(P,V) :-  obs_vlabel(P,V,S).


% forward propagation of signs
vlabel(P,V,1)  :- not input(P,V), infl(P,V,1), not infl(P,V,-1),     not obs_vlabel(P,V).
vlabel(P,V,-1) :- not input(P,V), infl(P,V,-1), not infl(P,V,1),     not obs_vlabel(P,V).
vlabel(P,V,0)  :- vertex(V), exp(P), not input(V), infl(P,V,0), not infl(P,V,-1), not infl(P,V,1), not obs_vlabel(P,V).

% influences
infl(P,V,1)  :- r_edge(U,V), elabel(U,V,1),  vlabel(P,U,1).
infl(P,V,1)  :- r_edge(U,V), elabel(U,V,-1), vlabel(P,U,-1).
infl(P,V,-1) :- r_edge(U,V), elabel(U,V,1),  vlabel(P,U,-1).
infl(P,V,-1) :- r_edge(U,V), elabel(U,V,-1), vlabel(P,U,1).

infl(P,V,0)  :- r_edge(U,V),                 vlabel(P,U,0).


% explained
% variation must be explained
explained(V,P) :- vlabel(P,V,1),  infl(P,V,1).
explained(V,P) :- vlabel(P,V,-1), infl(P,V,-1).
% no variation must {not} be explained
explained(V,P) :- vlabel(P,V,0),  infl(P,V,-1), infl(P,V,1).
explained(V,P) :- vlabel(P,V,0),  r_edge(U,V),  vlabel(P,U,0),
                  not infl(P,V,-1), not infl(P,V,1).
                  
% no inconsistencies
:- vertex(V), exp(P), not explained(V,P), not input(P,V).


% no diconnceted vertices
% in_edge(X) :- edge(Y,X), not repair(dedge(Y,X)).
% :- vertex(X), not in_edge(X), not input(X).

:- elabel(U,V,1), elabel(U,V,-1).

% optimize statement
#minimize[ not false4= 0, keep(U,V) ].
#minimize[ not false2 = 0, repair(aedge(U,V)) ]. 

#hide.
#show elabel/3.
#show vlabel/3.





